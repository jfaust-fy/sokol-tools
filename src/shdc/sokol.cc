/*
    Generate the output header for sokol_gfx.h
*/
#include "shdc.h"
#include "fmt/format.h"
#include "pystring.h"
#include <stdio.h>

namespace shdc {

static std::string file_content;

#if defined(_MSC_VER)
#define L(str, ...) file_content.append(fmt::format(str, __VA_ARGS__))
#else
#define L(str, ...) file_content.append(fmt::format(str, ##__VA_ARGS__))
#endif

static const char* uniform_type_str(uniform_t::type_t type) {
    switch (type) {
        case uniform_t::FLOAT: return "float";
        case uniform_t::FLOAT2: return "vec2";
        case uniform_t::FLOAT3: return "vec3";
        case uniform_t::FLOAT4: return "vec4";
        case uniform_t::MAT4: return "mat4";
        default: return "FIXME";
    }
}

static int uniform_type_size(uniform_t::type_t type) {
    switch (type) {
        case uniform_t::FLOAT:  return 4;
        case uniform_t::FLOAT2: return 8;
        case uniform_t::FLOAT3: return 12;
        case uniform_t::FLOAT4: return 16;
        case uniform_t::MAT4:   return 64;
        default: return 0;
    }
}

static int roundup(int val, int round_to) {
    return (val + (round_to - 1)) & ~(round_to - 1);
}

static const char* img_type_to_sokol_type_str(image_t::type_t type) {
    switch (type) {
        case image_t::IMAGE_TYPE_2D:    return "SG_IMAGETYPE_2D";
        case image_t::IMAGE_TYPE_CUBE:  return "SG_IMAGETYPE_CUBE";
        case image_t::IMAGE_TYPE_3D:    return "SG_IMAGETYPE_3D";
        case image_t::IMAGE_TYPE_ARRAY: return "SG_IMAGETYPE_ARRAY";
        default: return "INVALID";
    }
}

static const char* img_basetype_to_sokol_samplertype_str(image_t::basetype_t basetype) {
    switch (basetype) {
        case image_t::IMAGE_BASETYPE_FLOAT: return "SG_SAMPLERTYPE_FLOAT";
        case image_t::IMAGE_BASETYPE_SINT:  return "SG_SAMPLERTYPE_SINT";
        case image_t::IMAGE_BASETYPE_UINT:  return "SG_SAMPLERTYPE_UINT";
        default: return "INVALID";
    }
}

static const uniform_block_t* find_uniform_block(const spirvcross_refl_t& refl, int slot) {
    for (const uniform_block_t& ub: refl.uniform_blocks) {
        if (ub.slot == slot) {
            return &ub;
        }
    }
    return nullptr;
}

static const image_t* find_image(const spirvcross_refl_t& refl, int slot) {
    for (const image_t& img: refl.images) {
        if (img.slot == slot) {
            return &img;
        }
    }
    return nullptr;
}

static const char* sokol_define(slang_t::type_t slang) {
    switch (slang) {
        case slang_t::GLSL330:      return "SOKOL_GLCORE33";
        case slang_t::GLSL100:      return "SOKOL_GLES2";
        case slang_t::GLSL300ES:    return "SOKOL_GLES3";
        case slang_t::HLSL4:        return "SOKOL_D3D11";
        case slang_t::HLSL5:        return "SOKOL_D3D11";
        case slang_t::METAL_MACOS:  return "SOKOL_METAL";
        case slang_t::METAL_IOS:    return "SOKOL_METAL";
        case slang_t::METAL_SIM:    return "SOKOL_METAL";
        case slang_t::WGPU:         return "SOKOL_WGPU";
        default: return "<INVALID>";
    }
}

static const char* sokol_backend(slang_t::type_t slang) {
    switch (slang) {
        case slang_t::GLSL330:      return "SG_BACKEND_GLCORE33";
        case slang_t::GLSL100:      return "SG_BACKEND_GLES2";
        case slang_t::GLSL300ES:    return "SG_BACKEND_GLES3";
        case slang_t::HLSL4:        return "SG_BACKEND_D3D11";
        case slang_t::HLSL5:        return "SG_BACKEND_D3D11";
        case slang_t::METAL_MACOS:  return "SG_BACKEND_METAL_MACOS";
        case slang_t::METAL_IOS:    return "SG_BACKEND_METAL_IOS";
        case slang_t::METAL_SIM:    return "SG_BACKEND_METAL_SIMULATOR";
        case slang_t::WGPU:         return "SG_BACKEND_WGPU";
        default: return "<INVALID>";
    }
}

static void write_header(const args_t& args, const input_t& inp, const spirvcross_t& spirvcross) {
    L("/*\n");
    L("    #version:{}# (machine generated, don't edit!)\n\n", args.gen_version);
    L("    Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n\n");
    L("    Overview:\n\n");
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;

        int vs_snippet_index = inp.snippet_map.at(prog.vs_name);
        int fs_snippet_index = inp.snippet_map.at(prog.fs_name);
        int vs_src_index = spirvcross.find_source_by_snippet_index(vs_snippet_index);
        int fs_src_index = spirvcross.find_source_by_snippet_index(fs_snippet_index);
        assert((vs_src_index >= 0) && (fs_src_index >= 0));
        const spirvcross_source_t& vs_src = spirvcross.sources[vs_src_index];
        const spirvcross_source_t& fs_src = spirvcross.sources[fs_src_index];
        L("        Shader program '{}':\n", prog.name);
        L("            Get shader desc: {}{}_shader_desc()\n", mod_prefix(inp), prog.name);
        L("            Vertex shader: {}\n", prog.vs_name);
        L("                Attribute slots:\n");
        const snippet_t& vs_snippet = inp.snippets[vs_src.snippet_index];
        for (const attr_t& attr: vs_src.refl.inputs) {
            if (attr.slot >= 0) {
                L("                    ATTR_{}{}_{} = {}\n", mod_prefix(inp), vs_snippet.name, attr.name, attr.slot);
            }
        }
        for (const uniform_block_t& ub: vs_src.refl.uniform_blocks) {
            L("                Uniform block '{}':\n", ub.name);
            L("                    C struct: {}{}_t\n", mod_prefix(inp), ub.name);
            L("                    Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), ub.name, ub.slot);
        }
        for (const image_t& img: vs_src.refl.images) {
            L("                Image '{}':\n", img.name);
            L("                    Type: {}\n", img_type_to_sokol_type_str(img.type));
            L("                    Component Type: {}\n", img_basetype_to_sokol_samplertype_str(img.base_type));
            L("                    Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), img.name, img.slot);
        }
        L("            Fragment shader: {}\n", prog.fs_name);
        for (const uniform_block_t& ub: fs_src.refl.uniform_blocks) {
            L("                Uniform block '{}':\n", ub.name);
            L("                    C struct: {}{}_t\n", mod_prefix(inp), ub.name);
            L("                    Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), ub.name, ub.slot);
        }
        for (const image_t& img: fs_src.refl.images) {
            L("                Image '{}':\n", img.name);
            L("                    Type: {}\n", img_type_to_sokol_type_str(img.type));
            L("                    Component Type: {}\n", img_basetype_to_sokol_samplertype_str(img.base_type));
            L("                    Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), img.name, img.slot);
        }
        L("\n");
    }
    L("\n");
    L("    Shader descriptor structs:\n\n");
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;
        L("        sg_shader {} = sg_make_shader({}{}_shader_desc());\n", prog.name, mod_prefix(inp), prog.name);
    }
    L("\n");
    for (const spirvcross_source_t& src: spirvcross.sources) {
        if (src.refl.stage == stage_t::VS) {
            const snippet_t& vs_snippet = inp.snippets[src.snippet_index];
            L("    Vertex attribute locations for vertex shader '{}':\n\n", vs_snippet.name);
            L("        sg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){{\n");
            L("            .layout = {{\n");
            L("                .attrs = {{\n");
            for (const attr_t& attr: src.refl.inputs) {
                if (attr.slot >= 0) {
                    L("                    [ATTR_{}{}_{}] = {{ ... }},\n", mod_prefix(inp), vs_snippet.name, attr.name);
                }
            }
            L("                }},\n");
            L("            }},\n");
            L("            ...}});\n");
            L("\n");
        }
    }
    L("    Image bind slots, use as index in sg_bindings.vs_images[] or .fs_images[]\n\n");
    for (const image_t& img: spirvcross.unique_images) {
        L("        SLOT_{}{} = {};\n", mod_prefix(inp), img.name, img.slot);
    }
    L("\n");
    for (const uniform_block_t& ub: spirvcross.unique_uniform_blocks) {
        L("    Bind slot and C-struct for uniform block '{}':\n\n", ub.name);
        L("        {}{}_t {} = {{\n", mod_prefix(inp), ub.name, ub.name);
        for (const uniform_t& uniform: ub.uniforms) {
            L("            .{} = ...;\n", uniform.name);
        };
        L("        }};\n");
        L("        sg_apply_uniforms(SG_SHADERSTAGE_[VS|FS], SLOT_{}{}, &{}, sizeof({}));\n", mod_prefix(inp), ub.name, ub.name, ub.name);
        L("\n");
    }
    L("*/\n");
    L("#include <stdint.h>\n");
    L("#include <stdbool.h>\n");
}

static void write_vertex_attrs(const input_t& inp, const spirvcross_t& spirvcross) {
    // vertex attributes
    for (const spirvcross_source_t& src: spirvcross.sources) {
        if (src.refl.stage == stage_t::VS) {
            const snippet_t& vs_snippet = inp.snippets[src.snippet_index];
            for (const attr_t& attr: src.refl.inputs) {
                if (attr.slot >= 0) {
                    L("#define ATTR_{}{}_{} ({})\n", mod_prefix(inp), vs_snippet.name, attr.name, attr.slot);
                }
            }
        }
    }
}

static void write_images_bind_slots(const input_t& inp, const spirvcross_t& spirvcross) {
    for (const image_t& img: spirvcross.unique_images) {
        L("#define SLOT_{}{} ({})\n", mod_prefix(inp), img.name, img.slot);
    }
}

static void write_uniform_blocks(const input_t& inp, const spirvcross_t& spirvcross, slang_t::type_t slang) {
    for (const uniform_block_t& ub: spirvcross.unique_uniform_blocks) {
        L("#define SLOT_{}{} ({})\n", mod_prefix(inp), ub.name, ub.slot);
        L("#pragma pack(push,1)\n");
        int cur_offset = 0;
        L("SOKOL_SHDC_ALIGN(16) typedef struct {}{}_t {{\n", mod_prefix(inp), ub.name);
        for (const uniform_t& uniform: ub.uniforms) {
            int next_offset = uniform.offset;
            if (next_offset > cur_offset) {
                L("    uint8_t _pad_{}[{}];\n", cur_offset, next_offset - cur_offset);
                cur_offset = next_offset;
            }
            if (inp.type_map.count(uniform_type_str(uniform.type)) > 0) {
                // user-provided type names
                if (uniform.array_count == 1) {
                    L("    {} {};\n", inp.type_map.at(uniform_type_str(uniform.type)), uniform.name);
                }
                else {
                    L("    {} {}[{}];\n", inp.type_map.at(uniform_type_str(uniform.type)), uniform.name, uniform.array_count);
                }
            }
            else {
                // default type names (float)
                if (uniform.array_count == 1) {
                    switch (uniform.type) {
                        case uniform_t::FLOAT:   L("    float {};\n", uniform.name); break;
                        case uniform_t::FLOAT2:  L("    float {}[2];\n", uniform.name); break;
                        case uniform_t::FLOAT3:  L("    float {}[3];\n", uniform.name); break;
                        case uniform_t::FLOAT4:  L("    float {}[4];\n", uniform.name); break;
                        case uniform_t::MAT4:    L("    float {}[16];\n", uniform.name); break;
                        default:                 L("    INVALID_UNIFORM_TYPE;\n"); break;
                    }
                }
                else {
                    switch (uniform.type) {
                        case uniform_t::FLOAT:   L("    float {}[{}];\n", uniform.name, uniform.array_count); break;
                        case uniform_t::FLOAT2:  L("    float {}[{}][2];\n", uniform.name, uniform.array_count); break;
                        case uniform_t::FLOAT3:  L("    float {}[{}][3];\n", uniform.name, uniform.array_count); break;
                        case uniform_t::FLOAT4:  L("    float {}[{}][4];\n", uniform.name, uniform.array_count); break;
                        case uniform_t::MAT4:    L("    float {}[{}][16];\n", uniform.name, uniform.array_count); break;
                        default:                 L("    INVALID_UNIFORM_TYPE;\n"); break;
                    }
                }
            }
            cur_offset += uniform_type_size(uniform.type) * uniform.array_count;
        }
        /* pad to multiple of 16-bytes struct size */
        const int round16 = roundup(cur_offset, 16);
        if (cur_offset != round16) {
            L("    uint8_t _pad_{}[{}];\n", cur_offset, round16-cur_offset);
        }
        L("}} {}{}_t;\n", mod_prefix(inp), ub.name);
        L("#pragma pack(pop)\n");
    }
}

static void write_shader_sources_and_blobs(const input_t& inp,
                                           const spirvcross_t& spirvcross,
                                           const bytecode_t& bytecode,
                                           slang_t::type_t slang)
{
    for (int snippet_index = 0; snippet_index < (int)inp.snippets.size(); snippet_index++) {
        const snippet_t& snippet = inp.snippets[snippet_index];
        if ((snippet.type != snippet_t::VS) && (snippet.type != snippet_t::FS)) {
            continue;
        }
        int src_index = spirvcross.find_source_by_snippet_index(snippet_index);
        assert(src_index >= 0);
        const spirvcross_source_t& src = spirvcross.sources[src_index];
        int blob_index = bytecode.find_blob_by_snippet_index(snippet_index);
        const bytecode_blob_t* blob = 0;
        if (blob_index != -1) {
            blob = &bytecode.blobs[blob_index];
        }
        std::vector<std::string> lines;
        pystring::splitlines(src.source_code, lines);
        /* first write the source code in a comment block */
        L("/*\n");
        for (const std::string& line: lines) {
            L("    {}\n", line);
        }
        L("*/\n");
        if (blob) {
            std::string c_name = fmt::format("{}{}_bytecode_{}", mod_prefix(inp), snippet.name, slang_t::to_str(slang));
            L("static const uint8_t {}[{}] = {{\n", c_name.c_str(), blob->data.size());
            const size_t len = blob->data.size();
            for (size_t i = 0; i < len; i++) {
                if ((i & 15) == 0) {
                    L("    ");
                }
                L("{:#04x},", blob->data[i]);
                if ((i & 15) == 15) {
                    L("\n");
                }
            }
            L("\n}};\n");
        }
        else {
            /* if no bytecode exists, write the source code, but also a byte array with a trailing 0 */
            std::string c_name = fmt::format("{}{}_source_{}", mod_prefix(inp), snippet.name, slang_t::to_str(slang));
            const size_t len = src.source_code.length() + 1;
            L("static const char {}[{}] = {{\n", c_name.c_str(), len);
            for (size_t i = 0; i < len; i++) {
                if ((i & 15) == 0) {
                    L("    ");
                }
                L("{:#04x},", src.source_code[i]);
                if ((i & 15) == 15) {
                    L("\n");
                }
            }
            L("\n}};\n");
        }
    }
}

static void write_stage(const char* indent,
                        const char* stage_name,
                        const spirvcross_source_t& src,
                        const std::string& src_name,
                        const bytecode_blob_t* blob,
                        const std::string& blob_name,
                        slang_t::type_t slang)
{
    if (blob) {
        L("{}desc.{}.byte_code = {};\n", indent, stage_name, blob_name);
        L("{}desc.{}.byte_code_size = {};\n", indent, stage_name, blob->data.size());
    }
    else {
        L("{}desc.{}.source = {};\n", indent, stage_name, src_name);
        const char* d3d11_tgt = nullptr;
        if (slang == slang_t::HLSL4) {
            d3d11_tgt = (0 == strcmp("vs", stage_name)) ? "vs_4_0" : "ps_4_0";
        }
        else if (slang == slang_t::HLSL5) {
            d3d11_tgt = (0 == strcmp("vs", stage_name)) ? "vs_5_0" : "ps_5_0";
        }
        if (d3d11_tgt) {
            L("{}desc.{}.d3d11_target = \"{}\";\n", indent, stage_name, d3d11_tgt);
        }
    }
    L("{}desc.{}.entry = \"{}\";\n", indent, stage_name, src.refl.entry_point);
    for (int ub_index = 0; ub_index < uniform_block_t::NUM; ub_index++) {
        const uniform_block_t* ub = find_uniform_block(src.refl, ub_index);
        if (ub) {
            L("{}desc.{}.uniform_blocks[{}].size = {};\n", indent, stage_name, ub_index, roundup(ub->size, 16));
            if (slang_t::is_glsl(slang) && (ub->uniforms.size() > 0)) {

                L("{}desc.{}.uniform_blocks[{}].uniforms[0].name = \"{}\";\n", indent, stage_name, ub_index, ub->name);
                L("{}desc.{}.uniform_blocks[{}].uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;\n", indent, stage_name, ub_index);
                L("{}desc.{}.uniform_blocks[{}].uniforms[0].array_count = {};\n", indent, stage_name, ub_index, roundup(ub->size, 16) / 16);
            }
        }
    }
    for (int img_index = 0; img_index < image_t::NUM; img_index++) {
        const image_t* img = find_image(src.refl, img_index);
        if (img) {
            L("{}desc.{}.images[{}].name = \"{}\";\n", indent, stage_name, img_index, img->name);
            L("{}desc.{}.images[{}].type = {};\n", indent, stage_name, img_index, img_type_to_sokol_type_str(img->type));
            L("{}desc.{}.images[{}].sampler_type = {};\n", indent, stage_name, img_index, img_basetype_to_sokol_samplertype_str(img->base_type));
        }
    }
}

static void write_shader_desc_init(const char* indent, const program_t& prog, const input_t& inp, const spirvcross_t& spirvcross, const bytecode_t& bytecode, slang_t::type_t slang) {
    int vs_snippet_index = inp.snippet_map.at(prog.vs_name);
    int fs_snippet_index = inp.snippet_map.at(prog.fs_name);
    int vs_src_index = spirvcross.find_source_by_snippet_index(vs_snippet_index);
    int fs_src_index = spirvcross.find_source_by_snippet_index(fs_snippet_index);
    assert((vs_src_index >= 0) && (fs_src_index >= 0));
    const spirvcross_source_t& vs_src = spirvcross.sources[vs_src_index];
    const spirvcross_source_t& fs_src = spirvcross.sources[fs_src_index];
    int vs_blob_index = bytecode.find_blob_by_snippet_index(vs_snippet_index);
    int fs_blob_index = bytecode.find_blob_by_snippet_index(fs_snippet_index);
    const bytecode_blob_t* vs_blob = 0;
    const bytecode_blob_t* fs_blob = 0;
    if (vs_blob_index != -1) {
        vs_blob = &bytecode.blobs[vs_blob_index];
    }
    if (fs_blob_index != -1) {
        fs_blob = &bytecode.blobs[fs_blob_index];
    }
    std::string vs_src_name, fs_src_name;
    std::string vs_blob_name, fs_blob_name;
    if (vs_blob_index != -1) {
        vs_blob_name = fmt::format("{}{}_bytecode_{}", mod_prefix(inp), prog.vs_name, slang_t::to_str(slang));
    }
    else {
        vs_src_name = fmt::format("{}{}_source_{}", mod_prefix(inp), prog.vs_name, slang_t::to_str(slang));
    }
    if (fs_blob_index != -1) {
        fs_blob_name = fmt::format("{}{}_bytecode_{}", mod_prefix(inp), prog.fs_name, slang_t::to_str(slang));
    }
    else {
        fs_src_name = fmt::format("{}{}_source_{}", mod_prefix(inp), prog.fs_name, slang_t::to_str(slang));
    }

    /* write shader desc */
    for (int attr_index = 0; attr_index < attr_t::NUM; attr_index++) {
        const attr_t& attr = vs_src.refl.inputs[attr_index];
        if (attr.slot >= 0) {
            if (slang_t::is_glsl(slang)) {
                L("{}desc.attrs[{}].name = \"{}\";\n", indent, attr_index, attr.name);
            }
            else if (slang_t::is_hlsl(slang)) {
                L("{}desc.attrs[{}].sem_name = \"{}\";\n", indent, attr_index, attr.sem_name);
                L("{}desc.attrs[{}].sem_index = {};\n", indent, attr_index, attr.sem_index);
            }
        }
    }
    write_stage(indent, "vs", vs_src, vs_src_name, vs_blob, vs_blob_name, slang);
    write_stage(indent, "fs", fs_src, fs_src_name, fs_blob, fs_blob_name, slang);
    L("{}desc.label = \"{}{}_shader\";\n", indent, mod_prefix(inp), prog.name);
}

static void write_reflection_for_source(const input_t& inp, const spirvcross_t& spirvcross, const program_t& prog, const spirvcross_source_t& source, const char* shader_type) {
    L("const sg_shader_refl* {}{}_refl_{}(void) {{\n", mod_prefix(inp), prog.name, shader_type);

    const auto& refl = source.refl;
    L("    static sg_shader_refl refl;\n");
    L("    static bool valid = false;\n");
    L("    if (valid) return &refl;\n");
    L("    valid = true;\n");
    L("    refl.entry_point = \"{}\";\n", refl.entry_point);
    L("    refl.stage = (sg_shader_stage){};\n", refl.stage);

    size_t i;
    for (i = 0; i < refl.inputs.size(); ++i) {
        const attr_t& attr = refl.inputs[i];
        if (attr.slot < 0) {
            break;;
        }

        L("    refl.inputs[{}].slot = {};\n", i, attr.slot);
        L("    refl.inputs[{}].name = \"{}\";\n", i, attr.name);
        L("    refl.inputs[{}].sem_name = \"{}\";\n", i, attr.sem_name);
        L("    refl.inputs[{}].sem_index = {};\n", i, attr.sem_index);
    }
    if (i < attr_t::NUM) {
        L("    refl.inputs[{}].slot = -1;\n", i);
    }

    for (i = 0; i < refl.outputs.size(); ++i) {
        const attr_t& attr = refl.outputs[i];
        if (attr.slot < 0) {
            break;;
        }

        L("    refl.outputs[{}].slot = {};\n", i, attr.slot);
        L("    refl.outputs[{}].name = \"{}\";\n", i, attr.name);
        L("    refl.outputs[{}].sem_name = \"{}\";\n", i, attr.sem_name);
        L("    refl.outputs[{}].sem_index = {};\n", i, attr.sem_index);
    }
    if (i < attr_t::NUM) {
        L("    refl.outputs[{}].slot = -1;\n", i);
    }

    for (i = 0; i < refl.uniform_blocks.size(); ++i) {
        const uniform_block_t& block = refl.uniform_blocks[i];
        if (block.slot < 0) {
            continue;
        }

        L("    refl.uniform_blocks[{}].slot = {};\n", i, block.slot);
        L("    refl.uniform_blocks[{}].size = {};\n", i, block.size);
        L("    refl.uniform_blocks[{}].name = \"{}\";\n", i, block.name);
        size_t j;
        for (j = 0; j < block.uniforms.size(); ++j) {
            const uniform_t& uniform = block.uniforms[j];
            L("    refl.uniform_blocks[{}].uniforms[{}].name = \"{}\";\n", i, j, uniform.name);
            L("    refl.uniform_blocks[{}].uniforms[{}].type = (sg_uniform_type){};\n", i, j, uniform.type);
            L("    refl.uniform_blocks[{}].uniforms[{}].array_count = {};\n", i, j, uniform.array_count);
            L("    refl.uniform_blocks[{}].uniforms[{}].offset = {};\n", i, j, uniform.offset);
        }
        if (j < uniform_t::NUM) {
            L("    refl.uniform_blocks[{}].uniforms[{}].offset = -1;\n", i, j);
        }
    }
    if (i < uniform_block_t::NUM) {
        L("    refl.uniform_blocks[{}].slot = -1;\n", i);
    }

    for (i = 0; i < refl.images.size(); ++i) {
        const image_t& image = refl.images[i];
        if (image.slot < 0) {
            continue;
        }

        L("    refl.images[{}].slot = {};\n", i, image.slot);
        L("    refl.images[{}].name = \"{}\";\n", i, image.name);
        L("    refl.images[{}].type = (sg_image_type){};\n", i, image.type);
        L("    refl.images[{}].sampler_type = (sg_sampler_type){};\n", i, image.base_type);
    }
    if (i < image_t::NUM) {
        L("    refl.images[{}].slot = -1;\n", i);
    }

    L("    return &refl;\n");
    L("}}\n\n");
}

static void write_reflection(const input_t& inp, const spirvcross_t& spirvcross) {
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;
        int vs_snippet_index = inp.snippet_map.at(prog.vs_name);
        int fs_snippet_index = inp.snippet_map.at(prog.fs_name);
        int vs_src_index = spirvcross.find_source_by_snippet_index(vs_snippet_index);
        int fs_src_index = spirvcross.find_source_by_snippet_index(fs_snippet_index);
        assert((vs_src_index >= 0) && (fs_src_index >= 0));
        const spirvcross_source_t& vs_src = spirvcross.sources[vs_src_index];
        const spirvcross_source_t& fs_src = spirvcross.sources[fs_src_index];

        write_reflection_for_source(inp, spirvcross, prog, vs_src, "vs");
        write_reflection_for_source(inp, spirvcross, prog, fs_src, "fs");
    }
}

errmsg_t sokol_t::gen(const args_t& args, const input_t& inp,
                     const std::array<spirvcross_t,slang_t::NUM>& spirvcross,
                     const std::array<bytecode_t,slang_t::NUM>& bytecode)
{
    // first write everything into a string, and only when no errors occur,
    // dump this into a file (so we don't have half-written files lying around)
    file_content.clear();

    L("#pragma once\n");
    errmsg_t err;
    bool comment_header_written = false;
    bool common_decls_written = false;
    bool guard_written = false;
    std::map<std::string, bool> reflection_written_for_backend;
    for (int i = 0; i < slang_t::NUM; i++) {
        slang_t::type_t slang = (slang_t::type_t) i;
        if (args.slang & slang_t::bit(slang)) {
            errmsg_t err = output_t::check_errors(inp, spirvcross[i], slang);
            if (err.valid) {
                return err;
            }
            if (!comment_header_written) {
                write_header(args, inp, spirvcross[i]);
                comment_header_written = true;
            }
            if (!common_decls_written) {
                common_decls_written = true;
                if (args.output_format == format_t::SOKOL_IMPL) {
                    L("#if !defined(SOKOL_GFX_INCLUDED)\n");
                    L("  #error \"Please include sokol_gfx.h before {}\"\n", pystring::os::path::basename(args.output));
                    L("#endif\n");
                }
                L("#if !defined(SOKOL_SHDC_ALIGN)\n");
                L("  #if defined(_MSC_VER)\n");
                L("    #define SOKOL_SHDC_ALIGN(a) __declspec(align(a))\n");
                L("  #else\n");
                L("    #define SOKOL_SHDC_ALIGN(a) __attribute__((aligned(a)))\n");
                L("  #endif\n");
                L("#endif\n");
                if (args.output_format == format_t::SOKOL_IMPL) {
                    for (const auto& item: inp.programs) {
                        const program_t& prog = item.second;
                        L("const sg_shader_desc* {}{}_shader_desc(void);\n", mod_prefix(inp), prog.name);
                        L("const sg_shader_refl* {}{}_refl_vs(void);\n", mod_prefix(inp), prog.name);
                        L("const sg_shader_refl* {}{}_refl_fs(void);\n", mod_prefix(inp), prog.name);
                    }
                }
                write_vertex_attrs(inp, spirvcross[i]);
                write_images_bind_slots(inp, spirvcross[i]);
                write_uniform_blocks(inp, spirvcross[i], slang);
            }
            if (!guard_written) {
                guard_written = true;
                if (args.output_format == format_t::SOKOL_DECL) {
                    L("#if !defined(SOKOL_SHDC_DECL)\n");
                }
                else if (args.output_format == format_t::SOKOL_IMPL) {
                    L("#if defined(SOKOL_SHDC_IMPL)\n");
                }
            }

            if (args.ifdef) {
                L("#if defined({})\n", sokol_define(slang));
            }
            write_shader_sources_and_blobs(inp, spirvcross[i], bytecode[i], slang);
            if (!reflection_written_for_backend[sokol_define(slang)]) {
                write_reflection(inp, spirvcross[i]);
                reflection_written_for_backend[sokol_define(slang)] = true;
            }
            if (args.ifdef) {
                L("#endif /* {} */\n", sokol_define(slang));
            }
        }
    }

    // write access functions which return sg_shader_desc pointers
    if (args.output_format != format_t::SOKOL_IMPL) {
        L("#if !defined(SOKOL_GFX_INCLUDED)\n");
        L("  #error \"Please include sokol_gfx.h before {}\"\n", pystring::os::path::basename(args.output));
        L("#endif\n");
    }
    std::string func_prefix;
    if (args.output_format != format_t::SOKOL_IMPL) {
        func_prefix = "static inline ";
    }
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;
        L("{}const sg_shader_desc* {}{}_shader_desc(void) {{\n", func_prefix, mod_prefix(inp), prog.name);
        for (int i = 0; i < slang_t::NUM; i++) {
            slang_t::type_t slang = (slang_t::type_t) i;
            if (args.slang & slang_t::bit(slang)) {
                if (args.ifdef) {
                    L("  #if defined({})\n", sokol_define(slang));
                }
                L("  if (sg_query_backend() == {}) {{\n", sokol_backend(slang));
                L("    static sg_shader_desc desc;\n");
                L("    static bool valid;\n");
                L("    if (!valid) {{\n");
                L("      valid = true;\n");
                write_shader_desc_init("      ", prog, inp, spirvcross[i], bytecode[i], slang);
                L("    }};\n");
                L("    return &desc;\n", mod_prefix(inp), prog.name, slang_t::to_str(slang));
                L("  }}\n");
                if (args.ifdef) {
                    L("  #endif /* {} */\n", sokol_define(slang));
                }
            }
        }
        L("  return 0;\n");
        L("}}\n");
    }

    if (guard_written) {
        if (args.output_format == format_t::SOKOL_DECL) {
            L("#endif /* SOKOL_SHDC_DECL */\n");
        }
        else if (args.output_format == format_t::SOKOL_IMPL) {
            L("#endif /* SOKOL_SHDC_IMPL */\n");
        }
    }

    // write result into output file
    FILE* f = fopen(args.output.c_str(), "w");
    if (!f) {
        return errmsg_t::error(inp.base_path, 0, fmt::format("failed to open output file '{}'", args.output));
    }
    fwrite(file_content.c_str(), file_content.length(), 1, f);
    fclose(f);
    return errmsg_t();
}

} // namespace shdc
